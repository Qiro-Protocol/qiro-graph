// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class PoolDeployed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PoolDeployed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type PoolDeployed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("PoolDeployed", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): PoolDeployed | null {
    return changetype<PoolDeployed | null>(
      store.get_in_block("PoolDeployed", id.toHexString()),
    );
  }

  static load(id: Bytes): PoolDeployed | null {
    return changetype<PoolDeployed | null>(
      store.get("PoolDeployed", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get seniorRate(): BigInt {
    let value = this.get("seniorRate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set seniorRate(value: BigInt) {
    this.set("seniorRate", Value.fromBigInt(value));
  }

  get interestRate(): BigInt {
    let value = this.get("interestRate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set interestRate(value: BigInt) {
    this.set("interestRate", Value.fromBigInt(value));
  }

  get periodLength(): BigInt {
    let value = this.get("periodLength");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set periodLength(value: BigInt) {
    this.set("periodLength", Value.fromBigInt(value));
  }

  get periodCount(): BigInt {
    let value = this.get("periodCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set periodCount(value: BigInt) {
    this.set("periodCount", Value.fromBigInt(value));
  }

  get gracePeriod(): BigInt {
    let value = this.get("gracePeriod");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set gracePeriod(value: BigInt) {
    this.set("gracePeriod", Value.fromBigInt(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get shelf(): Bytes {
    let value = this.get("shelf");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set shelf(value: Bytes) {
    this.set("shelf", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Supply extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Supply entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Supply must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Supply", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Supply | null {
    return changetype<Supply | null>(
      store.get_in_block("Supply", id.toHexString()),
    );
  }

  static load(id: Bytes): Supply | null {
    return changetype<Supply | null>(store.get("Supply", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get supplier(): Bytes {
    let value = this.get("supplier");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set supplier(value: Bytes) {
    this.set("supplier", Value.fromBytes(value));
  }

  get currencyAmount(): BigInt {
    let value = this.get("currencyAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currencyAmount(value: BigInt) {
    this.set("currencyAmount", Value.fromBigInt(value));
  }

  get totalPoolBalance(): BigInt {
    let value = this.get("totalPoolBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalPoolBalance(value: BigInt) {
    this.set("totalPoolBalance", Value.fromBigInt(value));
  }

  get juniorPoolBalance(): BigInt {
    let value = this.get("juniorPoolBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set juniorPoolBalance(value: BigInt) {
    this.set("juniorPoolBalance", Value.fromBigInt(value));
  }

  get seniorPoolBalance(): BigInt {
    let value = this.get("seniorPoolBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set seniorPoolBalance(value: BigInt) {
    this.set("seniorPoolBalance", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Redeem extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Redeem entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Redeem must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Redeem", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Redeem | null {
    return changetype<Redeem | null>(
      store.get_in_block("Redeem", id.toHexString()),
    );
  }

  static load(id: Bytes): Redeem | null {
    return changetype<Redeem | null>(store.get("Redeem", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get tranche(): string {
    let value = this.get("tranche");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tranche(value: string) {
    this.set("tranche", Value.fromString(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }

  get tokenAmount(): BigInt {
    let value = this.get("tokenAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenAmount(value: BigInt) {
    this.set("tokenAmount", Value.fromBigInt(value));
  }

  get currencyAmount(): BigInt {
    let value = this.get("currencyAmount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set currencyAmount(value: BigInt) {
    this.set("currencyAmount", Value.fromBigInt(value));
  }

  get totalPoolBalance(): BigInt {
    let value = this.get("totalPoolBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalPoolBalance(value: BigInt) {
    this.set("totalPoolBalance", Value.fromBigInt(value));
  }

  get juniorPoolBalance(): BigInt {
    let value = this.get("juniorPoolBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set juniorPoolBalance(value: BigInt) {
    this.set("juniorPoolBalance", Value.fromBigInt(value));
  }

  get seniorPoolBalance(): BigInt {
    let value = this.get("seniorPoolBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set seniorPoolBalance(value: BigInt) {
    this.set("seniorPoolBalance", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Pool extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Pool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Pool must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Pool", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Pool | null {
    return changetype<Pool | null>(
      store.get_in_block("Pool", id.toHexString()),
    );
  }

  static load(id: Bytes): Pool | null {
    return changetype<Pool | null>(store.get("Pool", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get poolStatus(): string {
    let value = this.get("poolStatus");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set poolStatus(value: string) {
    this.set("poolStatus", Value.fromString(value));
  }

  get operator(): Bytes {
    let value = this.get("operator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set operator(value: Bytes) {
    this.set("operator", Value.fromBytes(value));
  }

  get shelf(): Bytes {
    let value = this.get("shelf");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set shelf(value: Bytes) {
    this.set("shelf", Value.fromBytes(value));
  }

  get juniorTranche(): Bytes {
    let value = this.get("juniorTranche");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set juniorTranche(value: Bytes) {
    this.set("juniorTranche", Value.fromBytes(value));
  }

  get seniorRate(): BigInt {
    let value = this.get("seniorRate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set seniorRate(value: BigInt) {
    this.set("seniorRate", Value.fromBigInt(value));
  }

  get seniorTranche(): Bytes {
    let value = this.get("seniorTranche");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set seniorTranche(value: Bytes) {
    this.set("seniorTranche", Value.fromBytes(value));
  }

  get interestRate(): BigInt {
    let value = this.get("interestRate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set interestRate(value: BigInt) {
    this.set("interestRate", Value.fromBigInt(value));
  }

  get periodLength(): BigInt {
    let value = this.get("periodLength");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set periodLength(value: BigInt) {
    this.set("periodLength", Value.fromBigInt(value));
  }

  get periodCount(): BigInt {
    let value = this.get("periodCount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set periodCount(value: BigInt) {
    this.set("periodCount", Value.fromBigInt(value));
  }

  get loanTerm(): BigInt {
    let value = this.get("loanTerm");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set loanTerm(value: BigInt) {
    this.set("loanTerm", Value.fromBigInt(value));
  }

  get gracePeriod(): BigInt {
    let value = this.get("gracePeriod");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set gracePeriod(value: BigInt) {
    this.set("gracePeriod", Value.fromBigInt(value));
  }

  get totalBalance(): BigInt {
    let value = this.get("totalBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalBalance(value: BigInt) {
    this.set("totalBalance", Value.fromBigInt(value));
  }

  get startTimestamp(): BigInt {
    let value = this.get("startTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set startTimestamp(value: BigInt) {
    this.set("startTimestamp", Value.fromBigInt(value));
  }

  get loanMaturityTimestamp(): BigInt {
    let value = this.get("loanMaturityTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set loanMaturityTimestamp(value: BigInt) {
    this.set("loanMaturityTimestamp", Value.fromBigInt(value));
  }

  get totalRepaid(): BigInt {
    let value = this.get("totalRepaid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalRepaid(value: BigInt) {
    this.set("totalRepaid", Value.fromBigInt(value));
  }

  get principalRepaid(): BigInt {
    let value = this.get("principalRepaid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set principalRepaid(value: BigInt) {
    this.set("principalRepaid", Value.fromBigInt(value));
  }

  get interestRepaid(): BigInt {
    let value = this.get("interestRepaid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set interestRepaid(value: BigInt) {
    this.set("interestRepaid", Value.fromBigInt(value));
  }

  get capitalFormationPeriod(): BigInt {
    let value = this.get("capitalFormationPeriod");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set capitalFormationPeriod(value: BigInt) {
    this.set("capitalFormationPeriod", Value.fromBigInt(value));
  }

  get capitalFormationPeriodEnd(): BigInt {
    let value = this.get("capitalFormationPeriodEnd");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set capitalFormationPeriodEnd(value: BigInt) {
    this.set("capitalFormationPeriodEnd", Value.fromBigInt(value));
  }

  get nextExpectedRepayment(): BigInt {
    let value = this.get("nextExpectedRepayment");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set nextExpectedRepayment(value: BigInt) {
    this.set("nextExpectedRepayment", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get lenders(): UserPoolLoader {
    return new UserPoolLoader(
      "Pool",
      this.get("id")!.toBytes().toHexString(),
      "lenders",
    );
  }

  get borrower(): Bytes | null {
    let value = this.get("borrower");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set borrower(value: Bytes | null) {
    if (!value) {
      this.unset("borrower");
    } else {
      this.set("borrower", Value.fromBytes(<Bytes>value));
    }
  }
}

export class Tranche extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Tranche entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Tranche must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Tranche", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Tranche | null {
    return changetype<Tranche | null>(
      store.get_in_block("Tranche", id.toHexString()),
    );
  }

  static load(id: Bytes): Tranche | null {
    return changetype<Tranche | null>(store.get("Tranche", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get trancheType(): string {
    let value = this.get("trancheType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set trancheType(value: string) {
    this.set("trancheType", Value.fromString(value));
  }

  get trancheAddress(): Bytes {
    let value = this.get("trancheAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set trancheAddress(value: Bytes) {
    this.set("trancheAddress", Value.fromBytes(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get totalBalance(): BigInt {
    let value = this.get("totalBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalBalance(value: BigInt) {
    this.set("totalBalance", Value.fromBigInt(value));
  }

  get totalTokenSupply(): BigInt {
    let value = this.get("totalTokenSupply");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalTokenSupply(value: BigInt) {
    this.set("totalTokenSupply", Value.fromBigInt(value));
  }

  get tokenPrice(): BigInt {
    let value = this.get("tokenPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenPrice(value: BigInt) {
    this.set("tokenPrice", Value.fromBigInt(value));
  }

  get ceiling(): BigInt {
    let value = this.get("ceiling");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set ceiling(value: BigInt) {
    this.set("ceiling", Value.fromBigInt(value));
  }

  get tokenName(): string {
    let value = this.get("tokenName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tokenName(value: string) {
    this.set("tokenName", Value.fromString(value));
  }

  get tokenSymbol(): string {
    let value = this.get("tokenSymbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tokenSymbol(value: string) {
    this.set("tokenSymbol", Value.fromString(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class LoanStarted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LoanStarted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type LoanStarted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("LoanStarted", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): LoanStarted | null {
    return changetype<LoanStarted | null>(
      store.get_in_block("LoanStarted", id.toHexString()),
    );
  }

  static load(id: Bytes): LoanStarted | null {
    return changetype<LoanStarted | null>(
      store.get("LoanStarted", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LoanEnded extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LoanEnded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type LoanEnded must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("LoanEnded", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): LoanEnded | null {
    return changetype<LoanEnded | null>(
      store.get_in_block("LoanEnded", id.toHexString()),
    );
  }

  static load(id: Bytes): LoanEnded | null {
    return changetype<LoanEnded | null>(
      store.get("LoanEnded", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LoanRepayed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LoanRepayed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type LoanRepayed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("LoanRepayed", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): LoanRepayed | null {
    return changetype<LoanRepayed | null>(
      store.get_in_block("LoanRepayed", id.toHexString()),
    );
  }

  static load(id: Bytes): LoanRepayed | null {
    return changetype<LoanRepayed | null>(
      store.get("LoanRepayed", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get amountRepayed(): BigInt {
    let value = this.get("amountRepayed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountRepayed(value: BigInt) {
    this.set("amountRepayed", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class LoanWithdrawn extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save LoanWithdrawn entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type LoanWithdrawn must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("LoanWithdrawn", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): LoanWithdrawn | null {
    return changetype<LoanWithdrawn | null>(
      store.get_in_block("LoanWithdrawn", id.toHexString()),
    );
  }

  static load(id: Bytes): LoanWithdrawn | null {
    return changetype<LoanWithdrawn | null>(
      store.get("LoanWithdrawn", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get poolId(): BigInt {
    let value = this.get("poolId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set poolId(value: BigInt) {
    this.set("poolId", Value.fromBigInt(value));
  }

  get amountWithdrawn(): BigInt {
    let value = this.get("amountWithdrawn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountWithdrawn(value: BigInt) {
    this.set("amountWithdrawn", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Lender extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Lender entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Lender must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Lender", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Lender | null {
    return changetype<Lender | null>(
      store.get_in_block("Lender", id.toHexString()),
    );
  }

  static load(id: Bytes): Lender | null {
    return changetype<Lender | null>(store.get("Lender", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get pools(): Array<BigInt> {
    let value = this.get("pools");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigIntArray();
    }
  }

  set pools(value: Array<BigInt>) {
    this.set("pools", Value.fromBigIntArray(value));
  }

  get totalInvested(): BigInt {
    let value = this.get("totalInvested");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalInvested(value: BigInt) {
    this.set("totalInvested", Value.fromBigInt(value));
  }

  get juniorInvestedBalance(): BigInt {
    let value = this.get("juniorInvestedBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set juniorInvestedBalance(value: BigInt) {
    this.set("juniorInvestedBalance", Value.fromBigInt(value));
  }

  get seniorInvestedBalance(): BigInt {
    let value = this.get("seniorInvestedBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set seniorInvestedBalance(value: BigInt) {
    this.set("seniorInvestedBalance", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Borrower extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Borrower entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Borrower must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Borrower", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Borrower | null {
    return changetype<Borrower | null>(
      store.get_in_block("Borrower", id.toHexString()),
    );
  }

  static load(id: Bytes): Borrower | null {
    return changetype<Borrower | null>(store.get("Borrower", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get poolsBorrowedFrom(): Array<BigInt> {
    let value = this.get("poolsBorrowedFrom");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigIntArray();
    }
  }

  set poolsBorrowedFrom(value: Array<BigInt>) {
    this.set("poolsBorrowedFrom", Value.fromBigIntArray(value));
  }

  get totalBorrowed(): BigInt {
    let value = this.get("totalBorrowed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalBorrowed(value: BigInt) {
    this.set("totalBorrowed", Value.fromBigInt(value));
  }

  get totalRepaid(): BigInt {
    let value = this.get("totalRepaid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalRepaid(value: BigInt) {
    this.set("totalRepaid", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }
}

export class Transaction extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transaction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Transaction must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Transaction", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Transaction | null {
    return changetype<Transaction | null>(
      store.get_in_block("Transaction", id.toHexString()),
    );
  }

  static load(id: Bytes): Transaction | null {
    return changetype<Transaction | null>(
      store.get("Transaction", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get hash(): Bytes {
    let value = this.get("hash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set hash(value: Bytes) {
    this.set("hash", Value.fromBytes(value));
  }

  get name(): string | null {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set name(value: string | null) {
    if (!value) {
      this.unset("name");
    } else {
      this.set("name", Value.fromString(<string>value));
    }
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get amountUSDC(): BigInt {
    let value = this.get("amountUSDC");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amountUSDC(value: BigInt) {
    this.set("amountUSDC", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }
}

export class User extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type User must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("User", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): User | null {
    return changetype<User | null>(
      store.get_in_block("User", id.toHexString()),
    );
  }

  static load(id: Bytes): User | null {
    return changetype<User | null>(store.get("User", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get isLender(): boolean {
    let value = this.get("isLender");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isLender(value: boolean) {
    this.set("isLender", Value.fromBoolean(value));
  }

  get isBorrower(): boolean {
    let value = this.get("isBorrower");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isBorrower(value: boolean) {
    this.set("isBorrower", Value.fromBoolean(value));
  }

  get poolsBorrowedFrom(): BorrowerPoolLoader {
    return new BorrowerPoolLoader(
      "User",
      this.get("id")!.toBytes().toHexString(),
      "poolsBorrowedFrom",
    );
  }

  get poolsLendedIn(): UserPoolLoader {
    return new UserPoolLoader(
      "User",
      this.get("id")!.toBytes().toHexString(),
      "poolsLendedIn",
    );
  }

  get totalLended(): BigInt {
    let value = this.get("totalLended");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalLended(value: BigInt) {
    this.set("totalLended", Value.fromBigInt(value));
  }

  get totalRedeemed(): BigInt {
    let value = this.get("totalRedeemed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalRedeemed(value: BigInt) {
    this.set("totalRedeemed", Value.fromBigInt(value));
  }

  get totalBorrowed(): BigInt {
    let value = this.get("totalBorrowed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalBorrowed(value: BigInt) {
    this.set("totalBorrowed", Value.fromBigInt(value));
  }

  get totalRepayed(): BigInt {
    let value = this.get("totalRepayed");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalRepayed(value: BigInt) {
    this.set("totalRepayed", Value.fromBigInt(value));
  }

  get transactionHistory(): Array<Bytes> {
    let value = this.get("transactionHistory");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytesArray();
    }
  }

  set transactionHistory(value: Array<Bytes>) {
    this.set("transactionHistory", Value.fromBytesArray(value));
  }
}

export class UserPool extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UserPool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type UserPool must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("UserPool", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): UserPool | null {
    return changetype<UserPool | null>(
      store.get_in_block("UserPool", id.toHexString()),
    );
  }

  static load(id: Bytes): UserPool | null {
    return changetype<UserPool | null>(store.get("UserPool", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get lendedPool(): Bytes {
    let value = this.get("lendedPool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set lendedPool(value: Bytes) {
    this.set("lendedPool", Value.fromBytes(value));
  }
}

export class BorrowerPool extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BorrowerPool entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BorrowerPool must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BorrowerPool", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BorrowerPool | null {
    return changetype<BorrowerPool | null>(
      store.get_in_block("BorrowerPool", id.toHexString()),
    );
  }

  static load(id: Bytes): BorrowerPool | null {
    return changetype<BorrowerPool | null>(
      store.get("BorrowerPool", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get borrowedPool(): Bytes {
    let value = this.get("borrowedPool");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set borrowedPool(value: Bytes) {
    this.set("borrowedPool", Value.fromBytes(value));
  }
}

export class ComputeSubscription extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ComputeSubscription entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type ComputeSubscription must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("ComputeSubscription", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): ComputeSubscription | null {
    return changetype<ComputeSubscription | null>(
      store.get_in_block("ComputeSubscription", id.toHexString()),
    );
  }

  static load(id: Bytes): ComputeSubscription | null {
    return changetype<ComputeSubscription | null>(
      store.get("ComputeSubscription", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get subscriptionId(): BigInt {
    let value = this.get("subscriptionId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set subscriptionId(value: BigInt) {
    this.set("subscriptionId", Value.fromBigInt(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get subscriptionResponses(): SubscriptionResponseLoader {
    return new SubscriptionResponseLoader(
      "ComputeSubscription",
      this.get("id")!.toBytes().toHexString(),
      "subscriptionResponses",
    );
  }

  get average_prob_of_default(): BigInt {
    let value = this.get("average_prob_of_default");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set average_prob_of_default(value: BigInt) {
    this.set("average_prob_of_default", Value.fromBigInt(value));
  }

  get average_loss_given_default(): BigInt {
    let value = this.get("average_loss_given_default");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set average_loss_given_default(value: BigInt) {
    this.set("average_loss_given_default", Value.fromBigInt(value));
  }

  get average_risk_score(): BigInt {
    let value = this.get("average_risk_score");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set average_risk_score(value: BigInt) {
    this.set("average_risk_score", Value.fromBigInt(value));
  }

  get average_exposure_at_default(): BigInt {
    let value = this.get("average_exposure_at_default");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set average_exposure_at_default(value: BigInt) {
    this.set("average_exposure_at_default", Value.fromBigInt(value));
  }
}

export class SubscriptionResponse extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SubscriptionResponse entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type SubscriptionResponse must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("SubscriptionResponse", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): SubscriptionResponse | null {
    return changetype<SubscriptionResponse | null>(
      store.get_in_block("SubscriptionResponse", id.toHexString()),
    );
  }

  static load(id: Bytes): SubscriptionResponse | null {
    return changetype<SubscriptionResponse | null>(
      store.get("SubscriptionResponse", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get subscription(): Bytes {
    let value = this.get("subscription");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set subscription(value: Bytes) {
    this.set("subscription", Value.fromBytes(value));
  }

  get output(): Bytes {
    let value = this.get("output");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set output(value: Bytes) {
    this.set("output", Value.fromBytes(value));
  }

  get input(): Bytes {
    let value = this.get("input");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set input(value: Bytes) {
    this.set("input", Value.fromBytes(value));
  }

  get proof(): Bytes {
    let value = this.get("proof");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proof(value: Bytes) {
    this.set("proof", Value.fromBytes(value));
  }

  get nodeAddress(): Bytes {
    let value = this.get("nodeAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nodeAddress(value: Bytes) {
    this.set("nodeAddress", Value.fromBytes(value));
  }

  get isProofVerifiedOnchain(): boolean {
    let value = this.get("isProofVerifiedOnchain");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set isProofVerifiedOnchain(value: boolean) {
    this.set("isProofVerifiedOnchain", Value.fromBoolean(value));
  }

  get prob_of_default(): BigInt {
    let value = this.get("prob_of_default");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set prob_of_default(value: BigInt) {
    this.set("prob_of_default", Value.fromBigInt(value));
  }

  get loss_given_default(): BigInt {
    let value = this.get("loss_given_default");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set loss_given_default(value: BigInt) {
    this.set("loss_given_default", Value.fromBigInt(value));
  }

  get risk_score(): BigInt {
    let value = this.get("risk_score");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set risk_score(value: BigInt) {
    this.set("risk_score", Value.fromBigInt(value));
  }

  get exposure_at_default(): BigInt {
    let value = this.get("exposure_at_default");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set exposure_at_default(value: BigInt) {
    this.set("exposure_at_default", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class MonitoringSubscription extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MonitoringSubscription entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type MonitoringSubscription must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("MonitoringSubscription", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): MonitoringSubscription | null {
    return changetype<MonitoringSubscription | null>(
      store.get_in_block("MonitoringSubscription", id.toHexString()),
    );
  }

  static load(id: Bytes): MonitoringSubscription | null {
    return changetype<MonitoringSubscription | null>(
      store.get("MonitoringSubscription", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get subscriptionId(): BigInt {
    let value = this.get("subscriptionId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set subscriptionId(value: BigInt) {
    this.set("subscriptionId", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get subscriptionResponses(): MonitoringResponseLoader {
    return new MonitoringResponseLoader(
      "MonitoringSubscription",
      this.get("id")!.toBytes().toHexString(),
      "subscriptionResponses",
    );
  }
}

export class MonitoringResponse extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MonitoringResponse entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type MonitoringResponse must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("MonitoringResponse", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): MonitoringResponse | null {
    return changetype<MonitoringResponse | null>(
      store.get_in_block("MonitoringResponse", id.toHexString()),
    );
  }

  static load(id: Bytes): MonitoringResponse | null {
    return changetype<MonitoringResponse | null>(
      store.get("MonitoringResponse", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get subscription(): Bytes {
    let value = this.get("subscription");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set subscription(value: Bytes) {
    this.set("subscription", Value.fromBytes(value));
  }

  get output(): Bytes {
    let value = this.get("output");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set output(value: Bytes) {
    this.set("output", Value.fromBytes(value));
  }

  get input(): Bytes {
    let value = this.get("input");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set input(value: Bytes) {
    this.set("input", Value.fromBytes(value));
  }

  get proof(): Bytes {
    let value = this.get("proof");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set proof(value: Bytes) {
    this.set("proof", Value.fromBytes(value));
  }

  get nodeAddress(): Bytes {
    let value = this.get("nodeAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set nodeAddress(value: Bytes) {
    this.set("nodeAddress", Value.fromBytes(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class UserPoolLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): UserPool[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<UserPool[]>(value);
  }
}

export class BorrowerPoolLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BorrowerPool[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BorrowerPool[]>(value);
  }
}

export class SubscriptionResponseLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): SubscriptionResponse[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<SubscriptionResponse[]>(value);
  }
}

export class MonitoringResponseLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): MonitoringResponse[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<MonitoringResponse[]>(value);
  }
}
