type PoolDeployed @entity(immutable: false) {
  id: Bytes!
  poolId: BigInt! # uint256 - webhook trigger
  pool: Pool! # uint256
  seniorRate: BigInt! # uint256
  interestRate: BigInt! # uint256
  periodLength: BigInt! # uint256
  periodCount: BigInt! # uint256
  gracePeriod: BigInt! # uint256
  operator: Bytes! # address
  shelf: Bytes! # address
  lateFeeInterestRate: BigInt! # uint256 - webhook trigger
  performanceFeeRate: BigInt! # uint256 - webhook trigger
  originatorFeeRate: BigInt! # uint256 - webhook trigger
  loanTerm: BigInt! # uint256 - webhook trigger
  currency: PoolCurrency! # address - webhook trigger
  poolType: PoolType! # enum - webhook trigger
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
} # done
type SupplyRedeem @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  poolId: BigInt! # uint256 - webhook trigger
  tranche: Tranche! # Tranche
  supplierOrReciever: Bytes! # address
  currencyAmount: BigInt!
  tokenAmount: BigInt!
  userLateFeePortion: BigInt! # uint256
  price: BigInt! # uint256
  totalPoolBalance: BigInt!
  juniorPoolBalance: BigInt!
  seniorPoolBalance: BigInt!
  actionType: SupplyRedeemType! # enum
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
} # done
enum PoolStatus {
  CAPITAL_FORMATION
  PENDING
  ACTIVE
  REVOKED
  REPAYMENT_STARTED
  REDEEM
  ENDED
}

enum SupplyRedeemType {
  SUPPLY
  REDEEM
}

enum PoolType {
  LOAN
  SECURITISATION
}

type FactoryOwnershipTransferred @entity(immutable: false) {
  id: Bytes!
  previousOwner: Bytes! # address
  newOwner: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
} # done
type QiroFactory @entity(immutable: false) {
  id: Bytes!
  shelfFab: Bytes! # address
  investmentOperatorFab: Bytes! # address
  whitelistOperatorFab: Bytes! # address
  defaultAssessorFab: Bytes! # address
  distributorFab: Bytes! # address
  seniorTrancheFab: Bytes! # address
  juniorTrancheFab: Bytes! # address
  qiroFeeCollector: Bytes! # address
  timelockVaultContract: Bytes! # address
  exitManagerContract: Bytes! # address
  pauserRole: Bytes! # address
  timelockManagerRole: Bytes! # address
  exitManagerOwnerRole: Bytes! # address
  owner: Bytes! # address
  whitelistManager: Bytes! # address
  poolCount: BigInt! # uint256
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  nftContractAddress: Bytes! # address
  currency: Bytes! # address
  protocolPaused: Boolean! # bool
  kycUsers: [KycUser!] @derivedFrom(field: "factory")
  whitelistedProtocols: [WhitelistedProtocol!] @derivedFrom(field: "factory")
} # done

# Factory-scoped KYC user
type KycUser @entity(immutable: false) {
  id: Bytes! # user address
  factory: QiroFactory!
  address: Bytes! # address
  isKyc: Boolean!
  blockTimestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes! #last updated transaction hash
}

# Factory-scoped whitelisted protocol
type WhitelistedProtocol @entity(immutable: false) {
  id: Bytes! # contract address
  factory: QiroFactory!
  address: Bytes! # address
  isWhitelisted: Boolean!
  blockTimestamp: BigInt!
  transactionHash: Bytes! #last updated transaction hash
}
# main Schema
type Pool @entity(immutable: false) {
  id: Bytes!
  poolId: BigInt! # uint256
  poolStatus: PoolStatus! # enum
  shelfBalance: BigInt! # uint256
  shelfDebt: BigInt! # uint256
  seniorInterestRate: BigInt! # uint256
  juniorInterestRate: BigInt! # uint256
  interestRate: BigInt! # uint256
  lateFeeInterestRate: BigInt! # uint256
  performanceFeeRate: BigInt! # uint256
  originatorFeeRate: BigInt! # uint256
  periodLength: BigInt! # uint256
  periodCount: BigInt! # uint256
  loanTerm: BigInt! # uint256
  gracePeriod: BigInt! # uint256
  totalBalance: BigInt! # uint256
  startTimestamp: BigInt! # uint256
  loanMaturityTimestamp: BigInt! # uint256
  totalRepaid: BigInt! # uint256
  principalRepaid: BigInt! # uint256
  interestRepaid: BigInt! # uint256
  prepaymentAbsorbedAmount: BigInt! # uint256
  prepaymentPeriod: BigInt! # uint256
  postPrePaymentOSPrincipal: BigInt! # uint256
  lateFeeRepaid: BigInt! # uint256
  capitalFormationPeriod: BigInt! # uint256
  capitalFormationPeriodEnd: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  principalAmount: BigInt! # uint256
  interestAmount: BigInt! # uint256
  writeoffAmount: BigInt! # uint256
  writeoffTime: BigInt! # uint256
  totalTrancheBalance: BigInt! # uint256
  trancheSupplyMaxBalance: BigInt! # uint256
  trancheTotalRedeemed: BigInt! # uint256
  outstandingPrincipal: BigInt! # uint256
  outstandingInterest: BigInt! # uint256
  isBullet: Boolean! # bool
  poolType: PoolType! # enum
  isPaused: Boolean! # bool
  borrower: Borrower! # address
  originatorFeePaid: BigInt! # uint256
  pStartFrom: BigInt! # uint256
  pRepayFrequency: BigInt! # uint256
  juniorTranche: Tranche!
  seniorTranche: Tranche!
  nftTokenId: BigInt! # uint256
  totalWithdrawn: BigInt! # uint256
  outstandingShortfallInterestAmount: BigInt! # uint256
  outstandingShortfallPrincipalAmount: BigInt! # uint256
  servicerFeePaid: BigInt! # uint256
  # reserve related fields
  reserveBalance: BigInt! # uint256 - latest borrower's balance() from reserve contract - when latest borrower deposits cash collateral
  eisBalance: BigInt! # uint256 - eisBalance from reserve contract
  maxServicerFeeAmount: BigInt! # uint256 - maxServicerFeeAmount from securitisation shelf contract
  recoveryAmountPaid: BigInt! # uint256 - recoveryAmountPaid from LOAN shelf contract
  addresses: PoolAddresses! @derivedFrom(field: "pool")
  # done
  lenders: [Lender!] @derivedFrom(field: "pool")
  repayments: [LoanRepayed!] @derivedFrom(field: "pool")
  withdrawals: [LoanWithdrawn!] @derivedFrom(field: "pool")
  supplyRedeems: [SupplyRedeem!] @derivedFrom(field: "pool")
  poolDeployed: PoolDeployed! @derivedFrom(field: "pool")
  prepaymentsApplied: [PrepaymentApplied!] @derivedFrom(field: "pool")
}

type PrepaymentApplied @entity(immutable: true) {
  id: Bytes!
  pool: Pool! # uint256
  prepaymentPeriod: BigInt! # uint256
  prepaymentAbsorbedAmount: BigInt! # uint256
  postPrePaymentOSPrincipal: BigInt! # uint256
  totalInterestForLoanTerm: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PoolAddresses @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  shelf: Bytes! # address
  operator: Bytes! # address
  investmentOperator: Bytes! # address
  juniorTranche: Bytes! # address
  seniorTranche: Bytes! # address
  lenderDeployer: Bytes! # address
  borrowerDeployer: Bytes! # address
  nftContractAddress: Bytes! # address
  admin: Bytes! # address
  currency: PoolCurrency!
  seniorToken: Bytes! # address
  juniorToken: Bytes! # address
  root: Bytes! # address
  reserve: Bytes! # address
} # done
type PoolCurrency @entity(immutable: false) {
  id: Bytes!
  address: Bytes! # address
  symbol: String!
  decimals: Int!
} # done
enum TrancheType {
  JUNIOR
  SENIOR
}

enum TransactionType {
  SUPPLY
  REDEEM
  REPAY
  WITHDRAW
}

enum TrancheTypeWithPool {
  JUNIOR
  SENIOR
  POOL
}

type Transaction @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  lenderOrBorrower: Bytes!
  amount: BigInt! # uint256
  type: TransactionType! # enum
  trancheType: TrancheTypeWithPool! # enum
  currency: PoolCurrency! # address
  transactionHash: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
}

type Tranche @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  trancheType: TrancheType!
  tokenAddress: Bytes! # address
  balance: BigInt!
  totalTokenSupply: BigInt!
  tokenName: String!
  tokenSymbol: String!
  tokenDecimals: Int!
  totalInvested: BigInt!
  totalRedeemed: BigInt!
  totalRepaid: BigInt!
  ceiling: BigInt! # uint256
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  # SecuritisationTranche-specific fields (optional - will be null for Loan Tranches)
  interestRate: BigInt # uint256 - for junior tranches in loan pool, this can be null
  principalRepaid: BigInt # uint256
  interestRepaid: BigInt # uint256
  overduePrincipalAmount: BigInt # uint256
  lastRepaidTimestamp: BigInt # uint256
  totalDaysRepaid: BigInt # uint256
} # done
type LoanStarted @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  poolId: BigInt! # uint256 - for webhook trigger
  nftContractAddress: Bytes! # address - for webhook trigger
  nftId: BigInt! # uint256 - for webhook trigger
  principalAmount: BigInt! # uint256 - for webhook trigger
  takeOriginatorFeeFromPrincipal: Boolean! # bool
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  blockNumber: BigInt!
} #done
type LoanEnded @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  poolId: BigInt! # uint256 - for webhook trigger
  principalRepaid: BigInt! # uint256
  interestRepaid: BigInt! # uint256
  lateFeeRepaid: BigInt! # uint256
  seniorTotalRepaid: BigInt! # uint256
  juniorTotalRepaid: BigInt! # uint256
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  blockNumber: BigInt!
} #done
type LoanRepayed @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  poolId: BigInt! # uint256 - for webhook trigger
  borrower: Borrower! # address
  amountRepayed: BigInt!
  # includes principal repaid and prepayment principal repaid
  principalRepayed: BigInt!
  interestRepayed: BigInt!
  prePaymentPrincipal: BigInt!
  lateFeeRepayed: BigInt!
  seniorTotalRepaid: BigInt!
  juniorTotalRepaid: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  blockNumber: BigInt!
} #done
type LoanWithdrawn @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  poolId: BigInt! # uint256 - for webhook trigger
  borrower: Borrower! # address
  withdrawTo: Bytes! # address
  poolPrincipal: BigInt! # uint256
  amount: BigInt! # uint256 - amount withdrawn from pool
  blockTimestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
} #done
type Lender @entity(immutable: false) {
  id: Bytes! # lenderAddress+poolId+trancheAddress
  address: Bytes! # address
  tranche: Tranche! # uint256
  pool: Pool! # uint256
  blockTimestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
  currencySupplied: BigInt # uint256 #pool level
  currencyRedeemed: BigInt # uint256 # pool level
  tokensRedeem: BigInt # uint256 # tranche level
  trancheTokenBalance: BigInt # uint256 # tranche level
} #done
type Borrower @entity(immutable: false) {
  id: Bytes!
  poolsBorrowedFrom: [Pool!] @derivedFrom(field: "borrower")
  blockTimestamp: BigInt!
} #done
# these are not included in implementation yet
type Rely @entity(immutable: false) {
  id: Bytes!
  usr: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Deny @entity(immutable: false) {
  id: Bytes!
  usr: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type File @entity(immutable: false) {
  id: Bytes!
  what: Bytes! # bytes32
  tokenId: BigInt! # uint256
  value: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NFTMinted @entity(immutable: false) {
  id: Bytes!
  to: Bytes! # address
  tokenId: BigInt! # uint256
  name: String! # string
  desc: String! # string
  imageURI: String! # string
  portfolioID: String! # string
  totalPrincipalAmount: BigInt! # uint256
  maturityDate: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  nftContractAddress: Bytes! # address
  arweaveId: String! # string
}

# ___________________________________________________________
# _______________ Compute Subscription Schema _______________
# ___________________________________________________________

type ComputeSubscription @entity(immutable: false) {
  id: Bytes!
  subscriptionId: BigInt!
  tokenId: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  subscriptionResponses: [SubscriptionResponse!]!
    @derivedFrom(field: "subscription")
  average_prob_of_default: BigInt!
  average_loss_given_default: BigInt!
  average_risk_score: BigInt!
  average_exposure_at_default: BigInt!
}

type SubscriptionResponse @entity(immutable: false) {
  id: Bytes!
  subscription: ComputeSubscription!
  output: Bytes!
  input: Bytes!
  proof: Bytes!
  nodeAddress: Bytes!
  isProofVerifiedOnchain: Boolean!
  prob_of_default: BigInt!
  loss_given_default: BigInt!
  risk_score: BigInt!
  exposure_at_default: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MonitoringSubscription @entity(immutable: false) {
  id: Bytes!
  subscriptionId: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  subscriptionResponses: [MonitoringResponse!]!
    @derivedFrom(field: "subscription")
}

type MonitoringResponse @entity(immutable: false) {
  id: Bytes!
  subscription: MonitoringSubscription!
  output: Bytes!
  input: Bytes!
  proof: Bytes!
  nodeAddress: Bytes!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ConsumerContractUpdated @entity(immutable: false) {
  id: Bytes!
  oldConsumer: Bytes! # address
  newConsumer: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Transfer @entity(immutable: false) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UpdateNftData @entity(immutable: false) {
  id: Bytes!
  tokenId: BigInt! # uint256
  prob_of_default: BigInt! # uint256
  loss_given_default: BigInt! # uint256
  risk_score: BigInt! # uint256
  exposure_at_default: BigInt! # uint256
  interest_rate: BigInt! # uint256
  nav: BigInt! # uint256
  isUnderwritten: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ConsumerCoordinatorPair @entity(immutable: false) {
  id: ID!
  consumer: Bytes!
  coordinator: Bytes!
}

# ______________________________________________________________
# _______________ Webhooks Schema ______________________________
# Note: Some entities mentioned above are also used for webhooks
# ______________________________________________________________

type WHInvestorWhitelisted @entity(immutable: false) {
  id: Bytes!
  investor: Bytes! # address
  trancheName: String! # string
  level: String! # string (pool, kycOnFactory)
  whitelisted: Boolean! # bool
  poolId: BigInt! # uint256
  contractAddress: Bytes! # address
  contractName: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WHWriteoff @entity(immutable: false) {
  id: Bytes!
  poolId: BigInt! # uint256
  writeoffAmount: BigInt! # uint256
  writeoffTime: BigInt! # uint256
  contractAddress: Bytes! # address
  contractName: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WHOriginatorFeePaid @entity(immutable: false) {
  id: Bytes!
  poolId: BigInt! # uint256
  amount: BigInt! # uint256
  feeRateBps: BigInt! # uint256
  principalAmount: BigInt! # uint256
  contractAddress: Bytes! # address
  contractName: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type WHSetCreatePoolAccess @entity(immutable: false) {
  id: Bytes!
  address: Bytes! # address - which can create pool
  canCreatePool: Boolean! # bool
  manager: Bytes! # address - address which gave access to create pool
  contractAddress: Bytes! # address
  contractName: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}