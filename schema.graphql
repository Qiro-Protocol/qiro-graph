type PoolDeployed @entity(immutable: true) {
  id: Bytes!
  poolId: BigInt! # uint256
  pool: Pool! # uint256
  seniorRate: BigInt! # uint256
  interestRate: BigInt! # uint256
  periodLength: BigInt! # uint256
  periodCount: BigInt! # uint256
  gracePeriod: BigInt! # uint256
  operator: Bytes! # address
  shelf: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
} # done

type SupplyRedeem @entity(immutable: true) {
  id: Bytes!
  pool: Pool! # uint256
  tranche: Tranche! # Tranche
  supplierOrReciever: Bytes! # address
  currencyAmount: BigInt!
  tokenAmount: BigInt!
  totalPoolBalance: BigInt!
  juniorPoolBalance: BigInt!
  seniorPoolBalance: BigInt!
  actionType: SupplyRedeemType! # enum
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
} # done

enum PoolStatus {
  CAPITAL_FORMATION
  PENDING
  ACTIVE
  ENDED
}

enum SupplyRedeemType {
  SUPPLY
  REDEEM
}

enum PoolType {
  LOAN
  SECURITIZATION
}

type QiroFactory @entity(immutable: true) {
  id: Bytes!
  shelfFab: Bytes! # address
  trustOperatorFab: Bytes! # address
  whitelistOperatorFab: Bytes! # address
  defaultAssessorFab: Bytes! # address
  distributorFab: Bytes! # address
  seniorTrancheFab: Bytes! # address
  juniorTrancheFab: Bytes! # address
  qiroFeeCollector: Bytes! # address
  owner: Bytes! # address
  whitelistManager: Bytes! # address
  poolCount: BigInt! # uint256
  blockTimestamp: BigInt!
  transactionHash: Bytes!
} # done

# main Schema
type Pool @entity(immutable: false) {
  id: Bytes!
  poolStatus: PoolStatus! # enum
  operator: Bytes! # address
  shelfBalance: BigInt! # uint256
  shelfDebt: BigInt! # uint256
  seniorInterestRate: BigInt! # uint256
  interestRate: BigInt! # uint256
  periodLength: BigInt! # uint256
  periodCount: BigInt! # uint256
  loanTerm: BigInt! # uint256
  gracePeriod: BigInt! # uint256
  totalBalance: BigInt! # uint256
  startTimestamp: BigInt! # uint256
  loanMaturityTimestamp: BigInt! # uint256
  totalRepaid: BigInt! # uint256
  principalRepaid: BigInt! # uint256
  interestRepaid: BigInt! # uint256
  capitalFormationPeriod: BigInt! # uint256
  capitalFormationPeriodEnd: BigInt! # uint256
  nextExpectedRepayment: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  interestAmount: BigInt! # uint256
  principalAmount: BigInt! # uint256
  writeoffAmount: BigInt! # uint256
  outstandingPrincipal: BigInt! # uint256
  totalTrancheBalance: BigInt! # uint256
  trancheSupplyMaxBalance: BigInt! # uint256
  outstandingPrincipal: BigInt! # uint256
  outstandingInterest: BigInt! # uint256
  isBullet: Boolean! # bool
  poolType: PoolType! # enum
  isPaused: Boolean! # bool
  juniorTranche: Tranche! @derivedFrom(field: "pool")
  seniorTranche: Tranche! @derivedFrom(field: "pool")
  lenders: [UserPool!] @derivedFrom(field: "lendedPool")
  borrower: BorrowerPool! @derivedFrom(field: "borrowedPool")
  addresses: PoolAddresses! @derivedFrom(field: "pool")
  currency: PoolCurrency! @derivedFrom(field: "pool")
  repayments: [LoanRepayed!] @derivedFrom(field: "pool")
  withdrawals: [LoanWithdrawn!] @derivedFrom(field: "pool")
  supplyRedeems: [SupplyRedeem!] @derivedFrom(field: "pool")
  poolDeployed: PoolDeployed! @derivedFrom(field: "pool")
}

type PoolAddresses @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  shelf: Bytes! # address
  operator: Bytes! # address
  trustOperator: Bytes! # address
  juniorTranche: Bytes! # address
  seniorTranche: Bytes! # address
  lenderDeployer: Bytes! # address
  borrowerDeployer: Bytes! # address
  admin: Bytes! # address
  currency: PoolCurrency!
  seniorToken: Bytes! # address
  juniorToken: Bytes! # address
  root: Bytes! # address
  # add more addresses as needed
}

type PoolCurrency @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  currencyAddress: Bytes! # address
  currencySymbol: String!
  currencyDecimals: Int!
}

enum TrancheType {
  JUNIOR
  SENIOR
}

type Tranche @entity(immutable: false) {
  id: Bytes!
  pool: Pool! # uint256
  trancheType: TrancheType!
  trancheAddress: Bytes!
  tokenAddress: Bytes! # address
  totalBalance: BigInt!
  totalTokenSupply: BigInt!
  tokenPrice: BigInt!
  tokenName: String!
  tokenSymbol: String!
  totalInvested: BigInt!
  totalRedeemed: BigInt!
  totalRepaid: BigInt!
  ceiling: BigInt! # uint256
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type LoanStarted @entity(immutable: true) {
  id: Bytes!
  pool: Pool! # uint256
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type LoanEnded @entity(immutable: true) {
  id: Bytes!
  pool: Pool! # uint256
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type LoanRepayed @entity(immutable: true) {
  id: Bytes!
  pool: Pool! # uint256
  borrower: Bytes! # address
  amountRepayed: BigInt!
  principalRepayed: BigInt!
  interestRepayed: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type LoanWithdrawn @entity(immutable: true) {
  id: Bytes!
  pool: Pool! # uint256
  borrower: Bytes! # address
  amountWithdrawn: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Lender @entity(immutable: false) {
  id: Bytes!
  address: Bytes!
  pools: [BigInt!]!
  totalInvested: BigInt!
  juniorInvestedBalance: BigInt!
  seniorInvestedBalance: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Borrower @entity(immutable: false) {
  id: Bytes!
  address: Bytes!
  poolsBorrowedFrom: [BigInt!]!
  totalBorrowed: BigInt!
  totalRepaid: BigInt!
  blockTimestamp: BigInt!
}

enum TxnTypes {
  MINT
  SENIOR_DEPOSIT
  JUNIOR_DEPOSIT
  SENIOR_REDEEM
  JUNIOR_REDEEM
  POOL_CREATED
  POOL_INITIALED
  BORROWER_WITHDRAW
  BORROWER_REPAY
}

type Transaction @entity(immutable: true) {
  id: Bytes!
  hash: Bytes!
  name: TxnTypes
  timestamp: BigInt!
  amountUSDC: BigInt!
  amount: BigInt!
  from: Bytes!
}

type User @entity(immutable: false) {
  id: Bytes!
  address: Bytes!
  isLender: Boolean!
  isBorrower: Boolean!
  poolsBorrowedFrom: [BorrowerPool!]! @derivedFrom(field: "user")
  poolsLendedIn: [UserPool!] @derivedFrom(field: "user")
  totalLended: BigInt!
  totalRedeemed: BigInt!
  totalBorrowed: BigInt!
  totalRepayed: BigInt!
  transactionHistory: [Transaction!]!
}

type UserPool @entity {
  id: Bytes!
  user: User!
  lendedPool: Pool!
}

type BorrowerPool @entity {
  id: Bytes!
  user: User!
  borrowedPool: Pool!
}

type Approval @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  approved: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ApprovalForAll @entity(immutable: true) {
  id: Bytes!
  owner: Bytes! # address
  operator: Bytes! # address
  approved: Boolean! # bool
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Deny @entity(immutable: true) {
  id: Bytes!
  usr: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type File @entity(immutable: true) {
  id: Bytes!
  what: Bytes! # bytes32
  tokenId: BigInt! # uint256
  value: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type NFTMinted @entity(immutable: true) {
  id: Bytes!
  to: Bytes! # address
  tokenId: BigInt! # uint256
  name: String! # string
  desc: String! # string
  imageURI: String! # string
  portfolioID: String! # string
  noOfLoans: BigInt! # uint256
  totalPrincipalAmount: BigInt! # uint256
  averageInterestRate: BigInt! # uint256
  portfolioTerm: String! # string
  portfolioStatus: String! # string
  writedown: BigInt! # uint256
  writeoff: BigInt! # uint256
  maturityDate: String! # string
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  nftContractAddress: Bytes! # address
  arweaveId: String! # string
}

type Rely @entity(immutable: true) {
  id: Bytes!
  usr: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# ___________________________________________________________
# _______________ Compute Subscription Schema _______________
# ___________________________________________________________

type ComputeSubscription @entity {
  id: Bytes!
  subscriptionId: BigInt!
  tokenId: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  subscriptionResponses: [SubscriptionResponse!]!
    @derivedFrom(field: "subscription")
  average_prob_of_default: BigInt!
  average_loss_given_default: BigInt!
  average_risk_score: BigInt!
  average_exposure_at_default: BigInt!
  coordinatorAddress: Bytes!
}

type SubscriptionResponse @entity {
  id: Bytes!
  subscription: ComputeSubscription!
  output: Bytes!
  input: Bytes!
  proof: Bytes!
  nodeAddress: Bytes!
  isProofVerifiedOnchain: Boolean!
  prob_of_default: BigInt!
  loss_given_default: BigInt!
  risk_score: BigInt!
  exposure_at_default: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type MonitoringSubscription @entity {
  id: Bytes!
  subscriptionId: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
  subscriptionResponses: [MonitoringResponse!]!
    @derivedFrom(field: "subscription")
}

type MonitoringResponse @entity {
  id: Bytes!
  subscription: MonitoringSubscription!
  output: Bytes!
  input: Bytes!
  proof: Bytes!
  nodeAddress: Bytes!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type ConsumerContractUpdated @entity(immutable: true) {
  id: Bytes!
  oldConsumer: Bytes! # address
  newConsumer: Bytes! # address
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type Transfer @entity(immutable: true) {
  id: Bytes!
  from: Bytes! # address
  to: Bytes! # address
  tokenId: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type UpdateNftData @entity(immutable: true) {
  id: Bytes!
  tokenId: BigInt! # uint256
  prob_of_default: BigInt! # uint256
  loss_given_default: BigInt! # uint256
  risk_score: BigInt! # uint256
  exposure_at_default: BigInt! # uint256
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# todo: @rahul7668gupta add entity to index all other data
